---
phase: 21-inbound-email-processing
plan: 02
type: execute
wave: 2
depends_on: ["21-01"]
files_modified:
  - ~/.openclaw/skills/resend-email/SKILL.md
  - n8n workflow (VPS)
autonomous: true
requirements: []

must_haves:
  truths:
    - "Replies appear in same email thread in Gmail and Outlook (In-Reply-To + References headers)"
    - "Subject line uses 'Re: ' prefix without stacking (no 'Re: Re: Re:')"
    - "All outbound replies include Auto-Submitted: auto-replied header"
    - "Outbound replies are recorded in email_conversations with direction=outbound and resend_email_id"
    - "Delivery status updates (delivered, bounced, complained) update email_conversations.delivery_status"
    - "Andy can add/remove senders from allowlist via Slack command to Bob"
    - "Bob can query conversation history by sender (show me emails with jane@example.com)"
  artifacts:
    - path: "~/.openclaw/skills/resend-email/SKILL.md"
      provides: "Reply threading instructions, allowlist management commands, conversation history queries"
      contains: "In-Reply-To"
    - path: "n8n workflow (VPS)"
      provides: "Delivery status event routing branch for email.delivered/bounced/complained"
      contains: "delivery_status"
  key_links:
    - from: "SKILL.md reply composition"
      to: "email_conversations (lookup thread data)"
      via: "sqlite3 SELECT to get message_id + references_chain for In-Reply-To/References headers"
    - from: "SKILL.md reply send"
      to: "Resend POST /emails"
      via: "curl with headers parameter including In-Reply-To, References, Auto-Submitted"
    - from: "SKILL.md reply recording"
      to: "email_conversations (INSERT outbound)"
      via: "sqlite3 INSERT with direction=outbound, resend_email_id from API response"
    - from: "n8n delivery status branch"
      to: "OpenClaw hooks endpoint"
      via: "POST /hooks/agent with delivery status update instruction"
    - from: "Bob delivery status handler"
      to: "email_conversations (UPDATE)"
      via: "sqlite3 UPDATE delivery_status WHERE resend_email_id = ?"
---

<objective>
Add reply threading with proper email headers (In-Reply-To + References), delivery status webhook processing via n8n, Slack-based allowlist management, and conversation history queries to the resend-email skill.

Purpose: Complete the email loop -- Bob can compose threaded replies that appear correctly in recipients' inboxes, track delivery outcomes, and manage the sender allowlist via conversational Slack commands.
Output: Full bidirectional email capability with threading, delivery tracking, allowlist management, and history queries.
</objective>

<execution_context>
@/Users/andykaufman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/andykaufman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-inbound-email-processing/21-RESEARCH.md
@.planning/phases/21-inbound-email-processing/21-01-SUMMARY.md
@.planning/phases/20-inbound-email-infrastructure/20-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add reply threading, allowlist management, and conversation queries to SKILL.md</name>
  <files>~/.openclaw/skills/resend-email/SKILL.md</files>
  <action>
SSH to EC2 and update the resend-email SKILL.md (which now has Sections 1-9 from Plan 01). Add these new sections:

**Section 10: Reply Threading (Composing Threaded Replies)**

When Andy says "reply to that email and say X", Bob must:

Step 1: Look up the inbound email in email_conversations to get threading data:
```bash
sqlite3 /workspace/email.db "SELECT message_id, references_chain, from_addr, subject FROM email_conversations WHERE direction='inbound' ORDER BY created_at DESC LIMIT 1;"
```
(Or match by sender/subject if Andy specifies. Use most recent matching inbound if ambiguous.)

Step 2: Run rate limit checks (Section 9) BEFORE composing.

Step 3: Build the reply with proper threading headers. Use python3 for safe JSON construction:

```python
import json, subprocess, os, re

# Data from email_conversations
original_msg_id = '<message-id from DB>'
existing_refs = 'references_chain from DB'  # may be empty for first reply
original_subject = 'subject from DB'
recipient = 'from_addr from DB'  # replying TO the original sender
reply_text = 'The reply content Andy dictated'

# Build References: existing chain + the message being replied to
refs = (existing_refs + ' ' + original_msg_id).strip() if existing_refs else original_msg_id

# Clean subject (no Re: stacking)
clean_subj = re.sub(r'^(Re:\s*)+', '', original_subject, flags=re.IGNORECASE).strip()
subject = f'Re: {clean_subj}'

# Build HTML from text (simple paragraphs)
reply_html = ''.join(f'<p>{line}</p>' for line in reply_text.split('\n') if line.strip())

payload = json.dumps({
    'from': 'Bob <bob@mail.andykaufman.net>',
    'to': [recipient],
    'subject': subject,
    'html': reply_html,
    'text': reply_text,
    'headers': {
        'In-Reply-To': original_msg_id,
        'References': refs,
        'Auto-Submitted': 'auto-replied'
    },
    'tags': [{'name': 'type', 'value': 'reply'}]
})

result = subprocess.run(
    ['curl', '-s', '-X', 'POST', 'https://api.resend.com/emails',
     '-H', f'Authorization: Bearer {os.environ["RESEND_API_KEY"]}',
     '-H', 'Content-Type: application/json',
     '-d', payload],
    capture_output=True, text=True
)
response = json.loads(result.stdout)
if 'id' in response:
    print(f'SENT:{response["id"]}')
else:
    print(f'ERROR:{result.stdout}')
```

Step 4: Record the outbound reply in email_conversations:
```bash
sqlite3 /workspace/email.db "INSERT INTO email_conversations (message_id, in_reply_to, references_chain, from_addr, to_addr, subject, summary, direction, resend_email_id, delivery_status) VALUES ('pending', '$ORIGINAL_MSG_ID', '$REFS', 'bob@mail.andykaufman.net', '$RECIPIENT', '$SUBJECT', '$REPLY_SUMMARY', 'outbound', '$RESEND_EMAIL_ID', 'sent');"
```
Note: `message_id` for outbound is 'pending' initially -- Resend generates the RFC Message-ID. If we need it later, fetch via GET /emails/{resend_email_id}.

Step 5: Confirm to Andy in Slack:
```
‚úÖ Reply sent to [recipient]
Subject: Re: [original subject]
Threading: In same conversation thread
```

**Threading rules (CRITICAL for correct thread grouping):**
- `In-Reply-To`: Set to the `message_id` (RFC 2822) of the email being replied to (the immediate parent)
- `References`: ALL previous message_ids in the thread chain, space-separated, chronological order. Take parent's references_chain and append parent's message_id
- `Subject`: Add `Re: ` prefix exactly once. Use regex to strip existing `Re:` prefixes first (case-insensitive)
- Both Gmail and Outlook use `References` for thread grouping; `In-Reply-To` links the direct parent

**Section 11: Allowlist Management**

When Andy says "add [email] to email allowlist" or "remove [email] from email allowlist":

Add sender:
```python
import json
with open('/workspace/email-config.json') as f:
    config = json.load(f)
if 'sender_allowlist' not in config:
    config['sender_allowlist'] = []
new_sender = 'email@example.com'
if new_sender.lower() not in [s.lower() for s in config['sender_allowlist']]:
    config['sender_allowlist'].append(new_sender)
    with open('/workspace/email-config.json', 'w') as f:
        json.dump(config, f, indent=2)
    print(f'Added {new_sender}')
else:
    print(f'{new_sender} already on allowlist')
```

Remove sender:
```python
import json
with open('/workspace/email-config.json') as f:
    config = json.load(f)
remove_sender = 'email@example.com'
config['sender_allowlist'] = [s for s in config.get('sender_allowlist', []) if s.lower() != remove_sender.lower()]
with open('/workspace/email-config.json', 'w') as f:
    json.dump(config, f, indent=2)
print(f'Removed {remove_sender}')
```

Show current allowlist:
```python
import json
with open('/workspace/email-config.json') as f:
    config = json.load(f)
print('Current allowlist:', config.get('sender_allowlist', []))
```

After add/remove, confirm to Andy:
```
‚úÖ Updated email allowlist
Added: jane@example.com
Current list: theandykaufman@gmail.com, kaufman@airspaceintegration.com, jane@example.com
```

**Section 12: Conversation History**

When Andy asks "show me my email thread with [sender]" or "what emails have I gotten from [sender]":

```sql
SELECT direction, from_addr, subject, summary, delivery_status, created_at
FROM email_conversations
WHERE from_addr LIKE '%sender@example.com%'
   OR to_addr LIKE '%sender@example.com%'
ORDER BY created_at ASC;
```

Format results as a readable thread:
```
üìß Email thread with jane@example.com (3 messages):

1. ‚¨áÔ∏è Inbound ‚Äî Feb 17, 2:30 PM
   Subject: Meeting tomorrow
   Summary: Jane confirmed the 3pm meeting and asked about the agenda...

2. ‚¨ÜÔ∏è Outbound ‚Äî Feb 17, 3:15 PM (delivered ‚úÖ)
   Subject: Re: Meeting tomorrow
   Summary: Confirmed attendance and shared agenda items...

3. ‚¨áÔ∏è Inbound ‚Äî Feb 17, 4:00 PM
   Subject: Re: Meeting tomorrow
   Summary: Jane acknowledged the agenda and suggested adding...
```

If Andy asks for a specific email's full body, fetch from Resend API:
```bash
curl -s -X GET "https://api.resend.com/emails/receiving/${RESEND_EMAIL_ID}" \
  -H "Authorization: Bearer $RESEND_API_KEY"
```

**Section 13: Delivery Status Handling**

When Bob receives a delivery status update via hook (from n8n, see Task 2):
- Extract `resend_email_id` and `status` from the hook payload
- Update the conversation record:
```bash
sqlite3 /workspace/email.db "UPDATE email_conversations SET delivery_status='$STATUS' WHERE resend_email_id='$RESEND_EMAIL_ID';"
```

Status values: sent, delivered, bounced, delayed, complained.

For bounced or complained: notify Andy in Slack:
```
‚ö†Ô∏è Email delivery issue
To: recipient@example.com
Subject: Re: Original subject
Status: bounced / complained
```

For delivered: no notification needed (silent success).
For delayed: no notification (transient, usually resolves).

**IMPORTANT NOTES for the skill text:**
- Preserve all existing sections (1-9, plus whatever Plan 01 added)
- Use the exact python3 reply composition pattern from research Example 2
- Reference /workspace/email.db and /workspace/email-config.json (sandbox paths)
- Include both the python3 code and the SQL queries inline in the SKILL.md
- Threading headers section must explain In-Reply-To vs References clearly
- Re: subject stacking prevention regex must be included
  </action>
  <verify>
1. `grep -c "In-Reply-To" ~/.openclaw/skills/resend-email/SKILL.md` returns at least 2 (header explanation + code)
2. `grep -c "References" ~/.openclaw/skills/resend-email/SKILL.md` returns at least 2
3. `grep -c "allowlist" ~/.openclaw/skills/resend-email/SKILL.md` returns at least 3 (add/remove/show)
4. `grep -c "delivery_status" ~/.openclaw/skills/resend-email/SKILL.md` returns at least 2
5. `grep -c "Conversation History" ~/.openclaw/skills/resend-email/SKILL.md` returns at least 1
6. `grep -c "Re:" ~/.openclaw/skills/resend-email/SKILL.md` shows subject stacking prevention
7. `openclaw skills list 2>/dev/null | grep -i resend` shows skill still detected as ready
  </verify>
  <done>
SKILL.md has Section 10 (Reply Threading) with complete python3 reply composition including In-Reply-To, References, and Re: subject deduplication. Section 11 (Allowlist Management) with add/remove/show commands. Section 12 (Conversation History) with sender thread queries and formatted output. Section 13 (Delivery Status Handling) with DB update and bounce/complaint notifications. All outbound replies include Auto-Submitted: auto-replied header.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add delivery status event routing to n8n workflow</name>
  <files>n8n workflow on VPS (ID: 1XwpGnGro0NYtOjE)</files>
  <action>
SSH to VPS (165.22.139.214) and update the existing n8n "Resend Inbound Email Relay" workflow to route delivery status events to OpenClaw.

The existing workflow handles `email.received` events. Delivery status events (`email.delivered`, `email.bounced`, `email.delivery_delayed`, `email.complained`) arrive at the same webhook endpoint but have different `type` values.

**Approach:** Modify the workflow so that after Svix signature verification, there is a branching point:
- `email.received` ‚Üí existing inbound processing pipeline (unchanged)
- `email.delivered`, `email.bounced`, `email.delivery_delayed`, `email.complained` ‚Üí POST to OpenClaw hooks with delivery status update

**Implementation via n8n Postgres direct update (same pattern as Plan 20-02):**

1. **First, examine the current workflow structure:**
   Connect to n8n's Postgres DB and inspect the workflow:
   ```bash
   docker exec -i n8n-production-postgres-1 psql -U n8n -d n8n -c "SELECT nodes FROM workflow_entity WHERE id = '1XwpGnGro0NYtOjE';" | head -100
   ```
   Understand the current node IDs, names, and connections.

2. **Add a routing Code node** after Svix verification that checks the event type:
   ```javascript
   // Route by event type
   const body = JSON.parse(Buffer.from($input.first().binary.data.data, 'base64').toString('utf-8'));
   const eventType = body.type || '';

   if (eventType === 'email.received') {
     return [{ json: { route: 'inbound', ...body } }];
   } else if (['email.delivered', 'email.bounced', 'email.delivery_delayed', 'email.complained'].includes(eventType)) {
     return [{ json: { route: 'delivery_status', ...body } }];
   } else {
     return [{ json: { route: 'unknown', type: eventType } }];
   }
   ```

   Actually, the simpler approach: modify the EXISTING "Extract Metadata" Code node to also handle delivery events. Add a conditional branch (IF node) after metadata extraction:
   - If `type === 'email.received'` ‚Üí continue to existing pipeline (Fetch Body Preview ‚Üí POST to OpenClaw)
   - If type matches delivery events ‚Üí new branch: POST to OpenClaw with delivery status payload

3. **Add a delivery status POST node** (HTTP Request node) that sends to EC2 hooks:
   ```
   POST http://100.72.143.9:18789/hooks/agent
   Headers:
     x-openclaw-token: 982cbc4b7e29edd465a8f1c411883122142d9f6dc5adc58a
     Content-Type: application/json
   Body:
   {
     "message": "Delivery status update: [type] for email [email_id] to [to]. Update email_conversations in /workspace/email.db: SET delivery_status='[mapped_status]' WHERE resend_email_id='[email_id]'. If bounced or complained, notify Andy in Slack.",
     "name": "delivery-status"
   }
   ```

   Map event types to status values:
   - `email.sent` ‚Üí `sent`
   - `email.delivered` ‚Üí `delivered`
   - `email.bounced` ‚Üí `bounced`
   - `email.delivery_delayed` ‚Üí `delayed`
   - `email.complained` ‚Üí `complained`

4. **Use SCP + Python script approach** for the Postgres update (same pattern that worked in Phase 20-02). Create a Python script locally, SCP to VPS, execute it against the Postgres container.

5. **Verify the workflow update:**
   ```bash
   docker exec -i n8n-production-postgres-1 psql -U n8n -d n8n -c "SELECT nodes FROM workflow_entity WHERE id = '1XwpGnGro0NYtOjE';" | python3 -c "import sys,json; nodes=json.loads(sys.stdin.read().strip().split('\n')[2].strip()); print([n['name'] for n in nodes])"
   ```
   Should show the new routing/delivery-status nodes.

6. **Check Resend webhook subscription** -- verify the webhook is subscribed to delivery events (not just `email.received`). This may require checking the Resend dashboard or API. If only `email.received` is subscribed, note this as a checkpoint for the user to add delivery event subscriptions in the Resend dashboard.

**IMPORTANT:** Do NOT break the existing inbound email pipeline. The `email.received` path must continue to work exactly as before. Test by sending an email to bob@mail.andykaufman.net after the workflow update and verifying Bob still receives the notification.
  </action>
  <verify>
1. Send a test email to bob@mail.andykaufman.net -- Bob should still receive the notification in Slack (existing pipeline unbroken)
2. Check n8n workflow nodes include delivery status routing logic
3. Verify the workflow is active: check n8n execution logs or Postgres `SELECT active FROM workflow_entity WHERE id = '1XwpGnGro0NYtOjE';`
4. Check n8n container is running: `docker ps | grep n8n`
  </verify>
  <done>
n8n workflow updated with delivery status event routing: email.received continues through existing pipeline, delivery events (delivered/bounced/delayed/complained) routed to OpenClaw hooks with status update instruction. Existing inbound email pipeline preserved and tested. Delivery status updates will flow to Bob who updates email_conversations.delivery_status accordingly.
  </done>
</task>

</tasks>

<verification>
1. E2E inbound test: Send email from allowlisted address ‚Üí Bob notifies in Slack with summary, records in DB
2. E2E reply test: Tell Bob "reply to that email and say thanks" ‚Üí Reply appears in same thread in Gmail
3. Rate limit test: Query `SELECT COUNT(*) FROM email_conversations WHERE direction='outbound' AND to_addr='recipient' AND created_at > datetime('now', '-1 hour');` returns count
4. Allowlist management: Tell Bob "add test@example.com to email allowlist" ‚Üí config updated, tell "remove test@example.com" ‚Üí config updated
5. Conversation history: Ask Bob "show me emails from [sender]" ‚Üí formatted thread output
6. Delivery status: After sending reply, check `SELECT delivery_status FROM email_conversations WHERE direction='outbound' ORDER BY created_at DESC LIMIT 1;` ‚Üí should update to 'delivered' within minutes
</verification>

<success_criteria>
- Replies thread correctly in Gmail and Outlook (In-Reply-To + References headers)
- Re: subject prefix applied exactly once (no stacking)
- All outbound replies include Auto-Submitted: auto-replied header
- Outbound replies recorded in email_conversations with resend_email_id
- Delivery status webhooks update email_conversations.delivery_status
- Bounce/complaint events trigger Slack notification to Andy
- Allowlist add/remove/show works via Slack commands
- Conversation history queryable by sender with formatted output
- Existing inbound email pipeline unbroken after n8n workflow update
</success_criteria>

<output>
After completion, create `.planning/phases/21-inbound-email-processing/21-02-SUMMARY.md`
</output>
