---
phase: 32-memory-office-visualization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/queries/memory.ts
  - src/app/api/memory/route.ts
  - src/components/memory/memory-card.tsx
  - src/components/memory/memory-search.tsx
  - src/app/memory/page.tsx
  - src/components/NavBar.tsx
autonomous: true
requirements: [MEM-01, MEM-02]

must_haves:
  truths:
    - "Opening /memory shows a grid of memory cards from all agents that have memory databases"
    - "Clicking an agent tab filters cards to only that agent's memories"
    - "Typing in the search bar filters cards across all agents using FTS5 full-text search"
    - "Clicking a memory card expands it to show the full content"
    - "NavBar shows Memory, Office, and Analytics links in correct order"
  artifacts:
    - path: "src/lib/queries/memory.ts"
      provides: "Multi-DB memory queries with FTS5 search"
      contains: "getMemoryFiles"
    - path: "src/app/api/memory/route.ts"
      provides: "Memory data endpoint with search and agent filter"
      exports: ["GET"]
    - path: "src/app/memory/page.tsx"
      provides: "Memory browser page with tabs, search, card grid"
      contains: "useSWR"
  key_links:
    - from: "src/app/memory/page.tsx"
      to: "/api/memory"
      via: "useSWR fetch with query params"
      pattern: "useSWR.*api/memory"
    - from: "src/app/api/memory/route.ts"
      to: "src/lib/queries/memory.ts"
      via: "getMemoryFiles and searchMemoryChunks"
      pattern: "getMemoryFiles|searchMemoryChunks"
    - from: "src/lib/queries/memory.ts"
      to: "~/.openclaw/memory/*.sqlite"
      via: "better-sqlite3 read-only connections"
      pattern: "new Database.*readonly"
---

<objective>
Build the /memory page with a card grid browser for agent memories, FTS5-powered search, agent tab filtering, and expandable card detail. Also update NavBar with Memory, Office, and Analytics links.

Purpose: MEM-01 and MEM-02 -- make agent memories browseable and searchable from Mission Control.
Output: Memory query module, API route, page component, NavBar update.
</objective>

<execution_context>
@/Users/andykaufman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/andykaufman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32-memory-office-visualization/32-RESEARCH.md
@.planning/phases/30-dashboard-metrics/30-01-SUMMARY.md
@.planning/phases/31-agent-board/31-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create memory query module and API route</name>
  <files>src/lib/queries/memory.ts, src/app/api/memory/route.ts</files>
  <action>
Create `src/lib/queries/memory.ts` with multi-database memory access:

1. Define constants:
   - `MEMORY_DIR = "/home/ubuntu/.openclaw/memory"` (path to per-agent SQLite files)
   - `MEMORY_AGENTS = ["main", "landos", "ops", "rangeos"]` (only agents with memory DBs, verified on EC2)
   - `AGENT_NAMES: Record<string, string>` mapping agent IDs to display names (main -> "Bob", landos -> "Scout", ops -> "Sentinel", rangeos -> "Vector")

2. `getMemoryDb(agentId: string): Database.Database | null` -- open per-agent SQLite file at `${MEMORY_DIR}/${agentId}.sqlite` with `{ readonly: true, fileMustExist: true }`. Return null on error. Unlike the shared DBs in db.ts (cached singletons), these should be opened per-request and closed after use since they're infrequently accessed.

3. `getMemoryFiles(agentId?: string): MemoryFile[]` -- query all 4 (or filtered) agent DBs. For each DB:
   - Query `SELECT id, path, text, start_line, end_line, updated_at FROM chunks ORDER BY path DESC, start_line ASC`
   - Group chunks by `path` field (each path = one memory file like "memory/2026-02-12.md")
   - For each group, create a MemoryFile: `{ path, agent_id, agent_name, updated_at (max of chunks), preview (first 200 chars of concatenated text), chunk_count }`
   - Close DB in finally block
   - Sort all results by updated_at DESC (most recent first)

4. `searchMemoryChunks(query: string, agentId?: string): SearchResult[]` -- FTS5 search:
   - Sanitize input: strip `[*^"(){}[\]:]` chars to prevent FTS5 syntax errors
   - If sanitized length < 2, return empty array
   - For each agent DB, run FTS5 MATCH query with `snippet(chunks_fts, 0, '<mark>', '</mark>', '...', 40)` for highlighted results
   - On FTS error, fall back to `LIKE '%query%'` on chunks.text
   - Close DB in finally block
   - Return results with agent_id, path, text, snippet, updated_at
   - Limit 30 results per agent

5. TypeScript interfaces: `MemoryFile`, `MemoryChunk`, `SearchResult`

Create `src/app/api/memory/route.ts`:
- `export const dynamic = "force-dynamic"`
- GET handler accepting query params: `?agent=main&search=email` (both optional)
- If `search` param present: call `searchMemoryChunks(search, agent)`, return `{ results, mode: "search" }`
- If no search: call `getMemoryFiles(agent)`, return `{ files, mode: "browse" }`
- Wrap in try/catch, return 500 with error message on failure
  </action>
  <verify>
SSH to EC2, curl http://localhost:3001/api/memory and confirm JSON response with files array. Then curl http://localhost:3001/api/memory?search=email and confirm search results with snippets. Then curl http://localhost:3001/api/memory?agent=main and confirm filtered results.
  </verify>
  <done>API returns memory files grouped by path with agent names and previews. Search returns FTS5 results with highlighted snippets. Agent filter narrows results correctly. Empty/error states handled gracefully.</done>
</task>

<task type="auto">
  <name>Task 2: Create memory browser page, components, and NavBar update</name>
  <files>src/components/memory/memory-card.tsx, src/components/memory/memory-search.tsx, src/app/memory/page.tsx, src/components/NavBar.tsx</files>
  <action>
Create `src/components/memory/memory-card.tsx` -- MemoryCard component:
- Props: `{ path, agent_id, agent_name, updated_at, preview, chunk_count, expanded, onToggle }`
- Render as shadcn Card with:
  - Header: agent name (colored by agent), file path (truncated to filename like "2026-02-12.md"), RelativeTime for updated_at (note: updated_at is Unix milliseconds, convert with `new Date(updated_at)`)
  - Body: 2-3 line preview with `line-clamp-3` truncation when collapsed
  - When expanded: show full preview text (no truncation), display chunk count as muted text
  - Click anywhere on card toggles expanded state
  - Card grid style: scannable like Notion database view -- consistent padding, clean typography, subtle border

Create `src/components/memory/memory-search.tsx` -- MemorySearch component:
- Search input with lucide Search icon, placeholder "Search memories..."
- Debounced input (300ms) using useState + useEffect with setTimeout pattern
- Calls `onSearch(value)` callback after debounce
- Clear button (X icon) when input has text

Create `src/app/memory/page.tsx`:
- Page title "Memory" with subtitle "Browse agent memories and conversations"
- Agent tabs across top: "All" tab + one tab per agent (only show agents from MEMORY_AGENTS: Bob, Scout, Sentinel, Vector -- NOT Quill/Sage/Ezra who have no memory DBs)
- Search bar below tabs (MemorySearch component)
- useSWR fetch to `/api/memory` with query params built from active tab and search text
- Card grid: responsive grid (3 cols lg, 2 cols md, 1 col sm) of MemoryCard components
- When search is active, show search results instead of browse results. Search result cards show the snippet with `<mark>` tags rendered as highlighted text (use dangerouslySetInnerHTML for the snippet only)
- Skeleton loader: 6 gray placeholder cards matching card shape while loading
- Empty state: "No memories found" with appropriate icon when no results
- Freshness indicator (reuse existing FreshnessIndicator pattern from dashboard)

Update `src/components/NavBar.tsx`:
- Add three new links after "Agents": Memory (/memory), Office (/office), Analytics (/analytics)
- Final nav order: Dashboard, Agents, Memory, Office, Analytics, Calendar
- Use lucide icons: Brain for Memory, Building2 for Office, BarChart3 for Analytics
  </action>
  <verify>
SSH to EC2, restart dev server. Visit http://100.72.143.9:3001/memory from Tailscale. Verify: card grid loads with memory files, agent tabs filter correctly, search returns highlighted results, cards expand on click, NavBar shows all 6 links in correct order.
  </verify>
  <done>/memory page displays agent memories in card grid, filterable by agent tabs and searchable via FTS5. Cards expand to show full content. NavBar updated with Memory, Office, and Analytics links in correct order.</done>
</task>

</tasks>

<verification>
1. /api/memory returns JSON with files array containing entries from all 4 memory agents
2. /api/memory?agent=main returns only Bob's memories
3. /api/memory?search=email returns FTS5 results with highlighted snippets
4. /memory page loads with card grid, tabs, and search bar
5. Agent tab switching filters cards in real-time
6. Search filtering works with debounced input
7. Memory cards expand on click to show full content
8. NavBar shows: Dashboard, Agents, Memory, Office, Analytics, Calendar
9. Skeleton loaders display during data fetch
10. Empty state handles gracefully when no results found
</verification>

<success_criteria>
- MEM-01: Memory browser page displays agent memories from SQLite, browseable by agent via tabs
- MEM-02: Global search across all agent memories works via FTS5 with highlighted results
- NavBar updated with all 3 new page links for Phase 32
</success_criteria>

<output>
After completion, create `.planning/phases/32-memory-office-visualization/32-01-SUMMARY.md`
</output>
