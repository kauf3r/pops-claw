---
phase: 21-inbound-email-processing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - ~/clawd/agents/main/email.db
  - ~/clawd/agents/main/email-config.json
  - ~/.openclaw/openclaw.json
  - ~/.openclaw/skills/resend-email/SKILL.md
autonomous: true
requirements: []

must_haves:
  truths:
    - "Auto-reply emails (OOF, noreply, mailer-daemon) are silently dropped with no Slack notification"
    - "Inbound from allowlisted sender produces Slack notification with sender, subject, and 2-3 line summary"
    - "Inbound from unknown sender produces Slack notification prefixed with [Unknown sender]"
    - "Every inbound email is recorded in email_conversations table with message_id, sender, subject, summary, direction"
    - "Rate limiter blocks >1 reply per sender per hour and halts all sending at 10 outbound in 5 minutes"
    - "email.db persists across container and gateway restarts"
  artifacts:
    - path: "~/clawd/agents/main/email.db"
      provides: "email_conversations table with indexes for threading, rate limiting, and sender lookup"
      contains: "email_conversations"
    - path: "~/clawd/agents/main/email-config.json"
      provides: "sender_allowlist array for closed allowlist"
      contains: "sender_allowlist"
    - path: "~/.openclaw/openclaw.json"
      provides: "email.db bind mount to /workspace/email.db"
      contains: "email.db"
    - path: "~/.openclaw/skills/resend-email/SKILL.md"
      provides: "Inbound email processing instructions: auto-reply detection, allowlist check, notification, rate limiting, conversation recording"
      contains: "Inbound Email Processing"
  key_links:
    - from: "OpenClaw hook (inbound email)"
      to: "Bob's SKILL.md inbound processing logic"
      via: "hook:inbound-email triggers Bob, SKILL.md instructs processing steps"
    - from: "SKILL.md auto-reply check"
      to: "Resend Received Emails API"
      via: "curl GET /emails/receiving/{id} to fetch full headers"
    - from: "SKILL.md allowlist check"
      to: "/workspace/email-config.json"
      via: "python3 reads config, compares sender against allowlist"
    - from: "SKILL.md conversation recording"
      to: "/workspace/email.db"
      via: "sqlite3 INSERT into email_conversations"
---

<objective>
Create email.db with conversation tracking schema, add sender allowlist to email-config.json, bind-mount DB into sandbox, and update resend-email SKILL.md with complete inbound email processing logic (auto-reply filter, allowlist check, Slack notification, rate limiting, conversation recording).

Purpose: Give Bob the intelligence layer to process inbound emails -- filtering automated junk, classifying senders, notifying Andy, and recording everything for conversation tracking.
Output: Working inbound processing pipeline where Bob fetches headers, filters auto-replies, checks allowlist, notifies via Slack, records in SQLite, and enforces rate limits.
</objective>

<execution_context>
@/Users/andykaufman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/andykaufman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-inbound-email-processing/21-RESEARCH.md
@.planning/phases/20-inbound-email-infrastructure/20-02-SUMMARY.md
@.planning/phases/19-outbound-email-foundation/19-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create email.db with schema, add allowlist to email-config.json, bind-mount DB</name>
  <files>~/clawd/agents/main/email.db, ~/clawd/agents/main/email-config.json, ~/.openclaw/openclaw.json</files>
  <action>
SSH to EC2 (100.72.143.9) and perform these steps:

1. **Create email.db with conversation schema on host:**
   ```
   sqlite3 ~/clawd/agents/main/email.db << 'SQL'
   CREATE TABLE email_conversations (
       id INTEGER PRIMARY KEY AUTOINCREMENT,
       message_id TEXT NOT NULL,
       in_reply_to TEXT,
       references_chain TEXT,
       from_addr TEXT NOT NULL,
       to_addr TEXT NOT NULL,
       subject TEXT,
       summary TEXT,
       direction TEXT NOT NULL CHECK(direction IN ('inbound', 'outbound')),
       resend_email_id TEXT,
       delivery_status TEXT DEFAULT 'unknown',
       created_at TEXT DEFAULT (datetime('now'))
   );
   CREATE INDEX idx_conversations_message_id ON email_conversations(message_id);
   CREATE INDEX idx_conversations_in_reply_to ON email_conversations(in_reply_to);
   CREATE INDEX idx_conversations_from ON email_conversations(from_addr, created_at);
   CREATE INDEX idx_conversations_outbound ON email_conversations(direction, created_at) WHERE direction = 'outbound';
   CREATE INDEX idx_conversations_resend_id ON email_conversations(resend_email_id);
   SQL
   ```

2. **Verify DB created correctly:**
   ```
   sqlite3 ~/clawd/agents/main/email.db ".schema"
   sqlite3 ~/clawd/agents/main/email.db ".tables"
   ```

3. **Add sender_allowlist to email-config.json:**
   Read current config, then add `sender_allowlist` array. Use python3 to safely merge:
   ```
   python3 -c "
   import json
   with open('/home/ubuntu/clawd/agents/main/email-config.json') as f:
       config = json.load(f)
   if 'sender_allowlist' not in config:
       config['sender_allowlist'] = ['theandykaufman@gmail.com', 'kaufman@airspaceintegration.com']
   with open('/home/ubuntu/clawd/agents/main/email-config.json', 'w') as f:
       json.dump(config, f, indent=2)
   print('Updated config:', json.dumps(config, indent=2))
   "
   ```

4. **Add email.db bind mount to openclaw.json:**
   Read current config, find the `sandbox.docker.binds` array (or `agents.defaults.sandbox.docker.binds`), and append:
   `"/home/ubuntu/clawd/agents/main/email.db:/workspace/email.db:rw"`

   Follow the exact same pattern used for health.db, coordination.db, and content.db bind mounts. Use jq or python3 to patch safely -- do NOT overwrite the full config.

5. **Also add /workspace/ symlink for embedded cron sessions** (same pattern as coordination.db):
   ```
   ls -la /workspace/  # Check existing symlinks
   sudo ln -sf /home/ubuntu/clawd/agents/main/email.db /workspace/email.db
   ```

6. **Restart gateway to apply bind mount:**
   ```
   systemctl --user restart openclaw-gateway.service
   sleep 3
   systemctl --user status openclaw-gateway.service
   ```

7. **Verify bind mount works** -- send a test message to Bob or check from a fresh session that /workspace/email.db is accessible:
   ```
   journalctl --user -u openclaw-gateway.service --since '30 sec ago' | tail -10
   ```
  </action>
  <verify>
1. `sqlite3 ~/clawd/agents/main/email.db ".schema"` shows email_conversations table with all columns and indexes
2. `sqlite3 ~/clawd/agents/main/email.db ".tables"` shows email_conversations
3. `python3 -c "import json; print(json.load(open('/home/ubuntu/clawd/agents/main/email-config.json')).get('sender_allowlist'))"` shows the allowlist array
4. `grep -c 'email.db' ~/.openclaw/openclaw.json` returns at least 1 (bind mount present)
5. `ls -la /workspace/email.db` shows symlink to host DB
6. Gateway service is active (running) after restart
  </verify>
  <done>
email.db exists on host with full schema (table + 5 indexes), email-config.json has sender_allowlist with Andy's two addresses, bind mount configured in openclaw.json, /workspace/ symlink created for embedded cron, gateway restarted and healthy.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update resend-email SKILL.md with inbound processing, auto-reply filter, allowlist, notification, and rate limiting</name>
  <files>~/.openclaw/skills/resend-email/SKILL.md</files>
  <action>
SSH to EC2 and update the existing resend-email SKILL.md to add inbound email processing sections. Read the current SKILL.md first to understand its structure (it has 7 sections per Phase 19).

**Add these new sections AFTER the existing 7 sections:**

**Section 8: Inbound Email Processing**

When Bob is woken by an inbound email hook (from n8n via Phase 20 pipeline), follow these steps IN ORDER:

Step 1: Fetch full email headers from Resend API:
```
curl -s -X GET "https://api.resend.com/emails/receiving/${EMAIL_ID}" \
  -H "Authorization: Bearer $RESEND_API_KEY"
```
Extract the `headers` object from the response. Headers are lowercase keys (Resend normalizes them). Also extract `message_id` (RFC 2822 Message-ID, NOT the Resend email_id UUID), `from`, `to`, `subject`, and the text body for summary generation.

CRITICAL: `message_id` = RFC 2822 Message-ID (angle brackets, for threading). `email_id` = Resend UUID (for API fetch). Do NOT confuse them.

Step 2: Auto-reply detection -- check headers in this order. If ANY match, silently drop (no notification, no recording):

```python
def is_auto_reply(headers):
    # 1. RFC 3834: Auto-Submitted (most authoritative)
    auto_submitted = headers.get('auto-submitted', '').lower()
    if auto_submitted and auto_submitted != 'no':
        return True
    # 2. Microsoft X-Auto-Response-Suppress
    xars = headers.get('x-auto-response-suppress', '').lower()
    if xars and any(v in xars for v in ['all', 'autoreply', 'dr', 'oof']):
        return True
    # 3. Precedence header
    if headers.get('precedence', '').lower() in ('bulk', 'auto_reply', 'list', 'junk'):
        return True
    # 4-5. X-Autoreply / X-Autorespond
    if headers.get('x-autoreply', '').lower() == 'yes':
        return True
    if headers.get('x-autorespond', ''):
        return True
    # 6. X-Loop
    if headers.get('x-loop', ''):
        return True
    # 7. From address patterns
    from_addr = headers.get('from', '').lower()
    for p in ['noreply@', 'no-reply@', 'no_reply@', 'donotreply@',
              'do-not-reply@', 'mailer-daemon@', 'postmaster@',
              'mail delivery subsystem']:
        if p in from_addr:
            return True
    # 8. Return-Path: <> (null sender = bounce/DSN)
    return_path = headers.get('return-path', '').strip()
    if return_path in ('<>', ''):
        return True
    return False
```

If auto-reply detected: stop processing. Do NOT notify Andy. Do NOT record in DB.

Step 3: Extract sender's bare email address from the `from` field. Handle "Display Name <email@domain.com>" format -- extract just the email part, lowercase.

Step 4: Allowlist check -- read /workspace/email-config.json, check sender against `sender_allowlist` (case-insensitive comparison of bare email addresses).

Step 5: Record inbound email in conversation DB:
```bash
sqlite3 /workspace/email.db "INSERT INTO email_conversations (message_id, in_reply_to, references_chain, from_addr, to_addr, subject, summary, direction, resend_email_id) VALUES ('$MESSAGE_ID', '$IN_REPLY_TO', '$REFERENCES', '$FROM', '$TO', '$SUBJECT', '$SUMMARY', 'inbound', '$RESEND_EMAIL_ID');"
```
Generate a 2-3 sentence summary of the email body for the `summary` field.

Step 6: Slack notification (use existing channel -- same as Phase 20 notifications):

For allowlisted senders:
```
ðŸ“§ *Inbound Email*
*From:* Display Name <email@example.com>
*Subject:* Subject line here
*Received:* Feb 17, 2026 2:30 PM PT

> 2-3 sentence summary of email content...

_Reply with: "reply to that email and say [your message]"_
```

For unknown senders (NOT on allowlist):
```
âš ï¸ *[Unknown Sender] Inbound Email*
*From:* unknown@company.com
*Subject:* Subject line here
*Received:* Feb 17, 2026 2:30 PM PT

> 2-3 sentence summary of email content...

_Unknown sender â€” not on allowlist. Say "add unknown@company.com to email allowlist" to allow future emails._
```

IMPORTANT: Bob does NOT auto-reply to ANY email. Always wait for Andy's explicit instruction.

**Section 9: Rate Limiting**

Before sending ANY outbound email (reply or otherwise), run these checks:

Check 1 -- Per-sender hourly limit (max 1 reply per sender per hour):
```bash
SENDER_COUNT=$(sqlite3 /workspace/email.db "SELECT COUNT(*) FROM email_conversations WHERE direction='outbound' AND to_addr='$RECIPIENT' AND created_at > datetime('now', '-1 hour');")
```
If SENDER_COUNT >= 1: BLOCK this reply. Tell Andy: "Rate limit: already replied to [recipient] in the last hour. Next reply available at [time]."

Check 2 -- Hard cap (10 outbound in any 5-minute window):
```bash
WINDOW_COUNT=$(sqlite3 /workspace/email.db "SELECT COUNT(*) FROM email_conversations WHERE direction='outbound' AND created_at > datetime('now', '-5 minutes');")
```
If WINDOW_COUNT >= 10: HALT ALL sending. Tell Andy: "HARD CAP REACHED: 10 outbound emails in 5 minutes. All email sending halted. This is a safety mechanism."

Both checks use UTC timestamps consistently (datetime('now') returns UTC). Rate limits are rolling windows, timezone-agnostic.

**IMPORTANT NOTES for the skill text:**
- Use the exact auto-reply detection function from research (Pattern 2)
- Instruct Bob to use python3 for JSON parsing of the Resend API response (safer than shell parsing)
- Reference /workspace/email.db and /workspace/email-config.json (sandbox paths)
- Include the rate limiting SQL queries exactly as shown
- Include Slack formatting examples with proper markdown
- Emphasize: NEVER auto-reply. ALWAYS wait for Andy's instruction.
- All outbound emails MUST include `Auto-Submitted: auto-replied` header per RFC 3834 (this is already in existing SKILL.md but reinforce it)
  </action>
  <verify>
1. `cat ~/.openclaw/skills/resend-email/SKILL.md | grep -c "Inbound Email Processing"` returns at least 1
2. `cat ~/.openclaw/skills/resend-email/SKILL.md | grep -c "auto-reply"` shows auto-reply detection is documented
3. `cat ~/.openclaw/skills/resend-email/SKILL.md | grep -c "sender_allowlist"` shows allowlist check is documented
4. `cat ~/.openclaw/skills/resend-email/SKILL.md | grep -c "Rate Limit"` shows rate limiting is documented
5. `cat ~/.openclaw/skills/resend-email/SKILL.md | grep -c "email_conversations"` shows conversation recording is documented
6. `openclaw skills list 2>/dev/null | grep -i resend` shows skill still detected as ready
7. Existing sections 1-7 are preserved (check section count or key phrases)
  </verify>
  <done>
resend-email SKILL.md has Section 8 (Inbound Email Processing) covering auto-reply detection with full RFC 3834 + vendor header checks, sender allowlist verification, conversation DB recording, and Slack notification formatting for both allowlisted and unknown senders. Section 9 (Rate Limiting) enforces 1 reply/sender/hour and 10/5min hard cap via SQLite queries. Existing sections 1-7 preserved. Bob instructed to NEVER auto-reply.
  </done>
</task>

</tasks>

<verification>
1. Send a test email to bob@mail.andykaufman.net from an allowlisted address -- Bob should notify in Slack with summary and NOT auto-reply
2. Send a test email from an unknown address -- Bob should notify with "[Unknown sender]" prefix
3. Verify auto-reply detection by checking if Bob's processing logic references the header checklist
4. Query email.db: `sqlite3 /workspace/email.db "SELECT COUNT(*) FROM email_conversations;"` should show recorded emails
5. Rate limit check: `sqlite3 /workspace/email.db "SELECT COUNT(*) FROM email_conversations WHERE direction='outbound' AND created_at > datetime('now', '-5 minutes');"` should return 0 (no outbound yet)
6. Gateway is healthy: `systemctl --user status openclaw-gateway.service` shows active
</verification>

<success_criteria>
- Auto-reply emails (OOF, noreply, mailer-daemon headers) silently dropped
- Allowlisted sender emails produce Slack notification with summary
- Unknown sender emails produce Slack notification with [Unknown sender] prefix
- All inbound emails recorded in email_conversations table
- Rate limiter logic present in SKILL.md (1/sender/hour + 10/5min hard cap)
- email.db persists across restarts (bind-mounted + /workspace/ symlink)
- Bob never auto-replies to any email
</success_criteria>

<output>
After completion, create `.planning/phases/21-inbound-email-processing/21-01-SUMMARY.md`
</output>
