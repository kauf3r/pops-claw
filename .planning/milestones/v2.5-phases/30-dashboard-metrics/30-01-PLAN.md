---
phase: 30-dashboard-metrics
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/constants.ts
  - src/lib/queries/agents.ts
  - src/lib/queries/crons.ts
  - src/lib/queries/metrics.ts
  - src/lib/queries/activity.ts
  - src/app/api/dashboard/agents/route.ts
  - src/app/api/dashboard/crons/route.ts
  - src/app/api/dashboard/metrics/route.ts
  - src/app/api/dashboard/activity/route.ts
  - src/app/providers.tsx
  - src/components/dashboard/status-card.tsx
autonomous: true
requirements: [DASH-01, DASH-02, DASH-03, PIPE-01, PIPE-02]

must_haves:
  truths:
    - "GET /api/dashboard/agents returns JSON with total, alive count, and per-agent status"
    - "GET /api/dashboard/crons returns JSON with total, enabled, successRate, and withErrors"
    - "GET /api/dashboard/metrics returns JSON with pipeline counts (researched/written/reviewed/published) and email metrics (sent/received/bounced/dailySent/monthlySent/quotas)"
    - "GET /api/dashboard/activity returns JSON with entries array (id, type, summary, timestamp) and hasMore boolean"
    - "SWR global config sets refreshInterval 30000 with fetcher function"
    - "StatusCard component renders headline number, colored dot, and detail text"
  artifacts:
    - path: "src/lib/constants.ts"
      provides: "Agent registry, email quota constants, activity type colors"
      contains: "AGENTS"
    - path: "src/lib/queries/agents.ts"
      provides: "Agent health query from coordination.db + observability.db"
      exports: ["getAgentHealth"]
    - path: "src/lib/queries/crons.ts"
      provides: "Cron summary from jobs.json"
      exports: ["getCronSummary"]
    - path: "src/lib/queries/metrics.ts"
      provides: "Content pipeline counts from content.db, email metrics from email.db"
      exports: ["getPipelineMetrics", "getEmailMetrics"]
    - path: "src/lib/queries/activity.ts"
      provides: "Cross-DB activity feed merge"
      exports: ["getActivity"]
    - path: "src/app/api/dashboard/agents/route.ts"
      provides: "Agent health API endpoint"
      exports: ["GET"]
    - path: "src/app/api/dashboard/crons/route.ts"
      provides: "Cron summary API endpoint"
      exports: ["GET"]
    - path: "src/app/api/dashboard/metrics/route.ts"
      provides: "Pipeline + email metrics API endpoint"
      exports: ["GET"]
    - path: "src/app/api/dashboard/activity/route.ts"
      provides: "Activity feed API endpoint"
      exports: ["GET"]
    - path: "src/app/providers.tsx"
      provides: "SWR global config with 30s polling"
      contains: "SWRConfig"
    - path: "src/components/dashboard/status-card.tsx"
      provides: "Reusable status card with headline + dot + detail"
      contains: "StatusCard"
  key_links:
    - from: "src/lib/queries/agents.ts"
      to: "src/lib/db.ts"
      via: "getDb('coordination') and getDb('observability')"
      pattern: "getDb\\("
    - from: "src/lib/queries/metrics.ts"
      to: "src/lib/db.ts"
      via: "getDb('content') and getDb('email')"
      pattern: "getDb\\("
    - from: "src/app/api/dashboard/agents/route.ts"
      to: "src/lib/queries/agents.ts"
      via: "import getAgentHealth"
      pattern: "getAgentHealth"
    - from: "src/app/providers.tsx"
      to: "swr"
      via: "SWRConfig with refreshInterval"
      pattern: "refreshInterval.*30000"
---

<objective>
Build the data layer and reusable components for the Phase 30 dashboard: query modules for all 4 subsystems (agents, crons, content pipeline, email), 4 API route handlers, SWR global polling configuration, and a reusable StatusCard component.

Purpose: Establish the complete data-fetching pipeline so Plan 02 can compose the dashboard UI purely from these building blocks.
Output: 4 API routes returning live data, SWR 30s polling configured, StatusCard component ready for use.
</objective>

<execution_context>
@/Users/andykaufman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/andykaufman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/30-dashboard-metrics/30-CONTEXT.md
@.planning/phases/30-dashboard-metrics/30-RESEARCH.md
@.planning/phases/29-infrastructure-database-foundation/29-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create query modules and constants</name>
  <files>
    src/lib/constants.ts
    src/lib/queries/agents.ts
    src/lib/queries/crons.ts
    src/lib/queries/metrics.ts
    src/lib/queries/activity.ts
  </files>
  <action>
Create `src/lib/constants.ts` with:
- AGENTS array: 7 agents [{id: "main", name: "Bob"}, {id: "landos", name: "Scout"}, {id: "rangeos", name: "Vector"}, {id: "ops", name: "Sentinel"}, {id: "quill", name: "Quill"}, {id: "sage", name: "Sage"}, {id: "ezra", name: "Ezra"}] as const
- AGENT_COUNT = 7
- EMAIL_DAILY_QUOTA = 100, EMAIL_MONTHLY_QUOTA = 3000 (Resend free tier)
- ACTIVITY_COLORS record: agent="text-blue-400", cron="text-purple-400", email="text-emerald-400", content="text-orange-400"
- ActivityEntry type: {id: string, type: "agent"|"cron"|"email"|"content", summary: string, agentId?: string, timestamp: string}
- StatusLevel type: "ok" | "warn" | "error"

Create `src/lib/queries/` directory and 4 query modules. All imports use `@/lib/db` for the existing getDb singleton factory.

`agents.ts` -- getAgentHealth():
- Import AGENTS from constants, getDb from db
- For each agent, check coordination.db `agent_activity` (latest created_at by agent_id) and observability.db `agent_runs` (latest created_at by agent_id). Take the more recent timestamp.
- Status logic: no data = "idle" (not "down"), last seen < 1 hour = "active", else "stale"
- Return {total: 7, alive: count of active, detail: "N/7 agents alive", agents: [...per-agent status]}
- Handle null DB (getDb returns null) gracefully -- return all idle

`crons.ts` -- getCronSummary():
- Read `/home/ubuntu/.openclaw/cron/jobs.json` via fs.readFileSync (NOT SQLite -- cron data is JSON)
- Count total, enabled, jobs with lastStatus=ok, jobs with consecutiveErrors > 0
- successRate = (ok / withAnyStatus) * 100, rounded
- Return {total, enabled, successRate, withErrors, detail: "N% success rate"}
- Wrap in try/catch, return zeros + "Cron data unavailable" on failure

`metrics.ts` -- getPipelineMetrics() and getEmailMetrics():
- getPipelineMetrics: Query content.db `SELECT status, count(*) as cnt FROM articles GROUP BY status`. content.db is currently 0 bytes, so getDb("content") returns null -- return zeros with {researched:0, written:0, reviewed:0, published:0, total:0}. Also check if articles table exists via sqlite_master before querying.
- getEmailMetrics: Query email.db for sent (direction='outbound'), received (direction='inbound'), bounced (direction='outbound' AND delivery_status='bounced'). Also daily sent (date(created_at) = date('now')) and monthly sent (strftime('%Y-%m', created_at) = strftime('%Y-%m', 'now')). Return {sent, received, bounced, total, bounceRate, dailySent, dailyQuota:100, monthlyQuota:3000, monthlySent}. Handle null DB -- return zeros.

`activity.ts` -- getActivity(offset?):
- Merge entries from up to 4 sources:
  1. coordination.db agent_activity: SELECT id, agent_id, activity_type, summary, created_at ORDER BY created_at DESC LIMIT 100. Map to ActivityEntry with type="agent", id="coord-{id}"
  2. observability.db agent_runs WHERE success=0: SELECT id, agent_id, error, created_at ORDER BY created_at DESC LIMIT 50. Map to type="agent", summary="Error: {error} ({agent_id})", id="obs-{id}"
  3. email.db email_conversations: SELECT id, direction, subject, created_at ORDER BY created_at DESC LIMIT 50. Map to type="email", summary="{Sent|Received}: {subject}", id="email-{id}"
  4. (content.db skipped for now -- 0 bytes, no schema)
- Normalize all timestamps with new Date(ts).toISOString() before sorting (coordination uses TEXT format, observability uses ISO)
- Sort all entries by timestamp DESC, slice to PAGE_SIZE=50 from offset
- Return {entries: [...], hasMore: boolean}
- Each source query wrapped in try/catch -- skip gracefully if DB unavailable
  </action>
  <verify>
SSH to EC2 and run: `cd ~/clawd/mission-control && npx tsx src/lib/queries/agents.ts 2>&1 | head -5` -- should parse without errors (no runtime test needed, TypeScript compile check). Also verify all 5 files exist: `ls src/lib/constants.ts src/lib/queries/agents.ts src/lib/queries/crons.ts src/lib/queries/metrics.ts src/lib/queries/activity.ts`
  </verify>
  <done>5 files created: constants.ts with AGENTS/quotas/types, and 4 query modules (agents, crons, metrics, activity) that import getDb and handle null/empty databases gracefully. No new npm packages needed.</done>
</task>

<task type="auto">
  <name>Task 2: Create API routes, SWR config, and StatusCard component</name>
  <files>
    src/app/api/dashboard/agents/route.ts
    src/app/api/dashboard/crons/route.ts
    src/app/api/dashboard/metrics/route.ts
    src/app/api/dashboard/activity/route.ts
    src/app/providers.tsx
    src/components/dashboard/status-card.tsx
  </files>
  <action>
Create 4 API route handlers under `src/app/api/dashboard/`. Each follows the same pattern:
- `export const dynamic = "force-dynamic"` at top (prevents Next.js caching)
- Export a GET function that calls the query module, wraps in try/catch
- On success: NextResponse.json(data)
- On error: NextResponse.json({...fallback, error: String(error)}, {status: 500})

`agents/route.ts`: import getAgentHealth from "@/lib/queries/agents", call it, return result. Fallback: {total:7, alive:0, detail:"Error loading agent data", agents:[], error}

`crons/route.ts`: import getCronSummary from "@/lib/queries/crons", call it, return result. Fallback: {total:0, enabled:0, successRate:0, withErrors:0, detail:"Error loading cron data", error}

`metrics/route.ts`: import getPipelineMetrics and getEmailMetrics from "@/lib/queries/metrics", call both, return {pipeline: {...}, email: {...}}. Fallback: {pipeline:{researched:0,...}, email:{sent:0,...}, error}

`activity/route.ts`: import getActivity from "@/lib/queries/activity". Read `offset` from URL searchParams (default 0). Call getActivity(offset), return result. Fallback: {entries:[], hasMore:false, error}

Rewrite `src/app/providers.tsx` (currently a clean passthrough from Phase 29):
- Add "use client" directive
- Import SWRConfig from "swr"
- Create fetcher function: `(url: string) => fetch(url).then(res => { if (!res.ok) throw new Error(\`API error: \${res.status}\`); return res.json(); })`
- Wrap children in SWRConfig with value: {fetcher, refreshInterval: 30000, revalidateOnFocus: true, dedupingInterval: 5000}

Create `src/components/dashboard/status-card.tsx` (per user's locked decision -- clean, not busy):
- "use client" component
- Import Card, CardContent from "@/components/ui/card"
- Import StatusLevel from "@/lib/constants"
- DOT_COLORS map: ok="bg-emerald-500", warn="bg-amber-500", error="bg-rose-500"
- Props: {title: string, headline: string, detail: string, status: StatusLevel, icon: React.ReactNode}
- Render: Card with CardContent containing icon box (h-10 w-10 rounded-lg bg-secondary), then title (text-xs uppercase tracking-wider text-muted-foreground), headline (text-2xl font-bold) with dot next to it, and detail (text-sm text-muted-foreground)
- This matches the locked decision: single headline number, colored dot indicator, one-line detail, clean and not busy
  </action>
  <verify>
SSH to EC2 and rebuild: `cd ~/clawd/mission-control && npm run build 2>&1 | tail -20` -- build should succeed. Then test API routes: `curl -s http://localhost:3001/api/dashboard/agents | python3 -m json.tool | head -10` and `curl -s http://localhost:3001/api/dashboard/crons | python3 -m json.tool | head -10` and `curl -s http://localhost:3001/api/dashboard/metrics | python3 -m json.tool | head -10` and `curl -s http://localhost:3001/api/dashboard/activity | python3 -m json.tool | head -10` -- all 4 should return valid JSON without errors.
  </verify>
  <done>4 API routes return live data from SQLite/JSON. SWR global config polls every 30 seconds. StatusCard component renders headline+dot+detail layout per locked design. Build succeeds and all 4 endpoints return valid JSON.</done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds on EC2 with zero errors
2. All 4 API routes return valid JSON: `/api/dashboard/agents`, `/api/dashboard/crons`, `/api/dashboard/metrics`, `/api/dashboard/activity`
3. Agent health shows 7 total with correct alive/stale/idle breakdown
4. Cron summary shows 20 total, ~95% success rate
5. Pipeline metrics shows zeros (content.db is 0 bytes -- expected)
6. Email metrics shows zeros (email.db has 0 rows -- expected)
7. Activity feed shows entries from coordination.db (119 agent_activity rows)
8. providers.tsx wraps children in SWRConfig with refreshInterval: 30000
</verification>

<success_criteria>
- All 4 `/api/dashboard/*` routes return correctly shaped JSON
- Query modules handle null databases (content.db, email.db) without crashing
- SWR configured globally with 30-second polling
- StatusCard component exists with locked design (headline + dot + detail)
- `npm run build` passes cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/30-dashboard-metrics/30-01-SUMMARY.md`
</output>
